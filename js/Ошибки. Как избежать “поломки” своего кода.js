"use strict";

try {
    console.log("Normal"); // Сюда помещаем действие, которое хотим выполнить. В случае успешного выполения, блок catch игнорируется. Наш код продолжает работать и дальше выполняются определенные команды.
    console.log(a);
    console.log("result");
} catch (e) { // В блок catch приходит также объект ошибки.
    console.log("Error"); // Но если вдруг в блоке try, у нас возникла какая-то ошибка, то мы переместимся в блок catch. После ошибки в блоке try, блок try перестает полностью работать.
    console.log(e); // Сама ошибка
    console.log(e.name); // Название нашей ошибки
    console.log(e.message); // Сообщение которое говорит об ошибке
    console.log(e.stack); // Какие функции привели к нашей ошибке.
} finally {
    // Задача этого блока состоит в завершении начатых операций при любых развитиях событий. Если вдруг в try оборвался какой-то процесс, то чтобы его закончить и показать какой-то результат хотя-бы промежуточный. Либо сказать пользователю, что что-то пошло не так. Мы можем использовать эту секцию.

}

// Самый плюс состоит в том, что код после данной конструкции продолжит работать. На всякий напомню, что в случае ошибки в скрипте, дальнейший код у нас работать не будет.

console.log("Still normal");

// Данный блок можно использовать, в случае, когда у нас много страниц и мы пишем скрипт для всех страниц. Допустим у нас есть 1 страница и 1 элемент который есть на этой странице. Мы просто пишем обработчик события для этого элемента и на этой странице все прекрасно работает. Но вот когда, мы зайдем на другую страницу то у нас будет ошибка, так как на этой странице тупо нет этого элемента. И именно для этого нам нужен try catch. В случае, если у нас что-то сломается на другой странице оно просто выйдет в catch и ничего не сломается.

try {
    document.querySelector(".active").addEventListener("click", () => {
        console.log("click");
    });
} catch (e) {
    console.log(e);
}

console.log("Normal");