"use strict";

const req = new Promise((resolve, reject) => { // Это параметры вместо которых у нас будут подставляться функции. Если все хорошо, вызываем resolve, если нет, то вызываем reject.

    setTimeout(() => {
        // Дальше идёт имитация асинхронного кода.
        console.log("Подготовка данных...");

        const product = {
            name: "TV",
            price: 2000
        }; // Если выполнился product, значит все в порядке и мы должны вызвать функцию resolve

        resolve(product); // Мы вызываем функцию resolve и передаем аргумент product
    }, 2000);
});

req.then((product) => { // функция вызывается и ей передается в качестве аргумента product.
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            product.status = "order";
            resolve(product); // Это функция выполняется, когда произошла ошибка.
        }, 2000);
    });
}).then(data => {
    data.modify = true;
    return data;
}).then(data => { // Для того, чтобы обрабатывать положительный результат, у нас есть такой метод как then().then - это метод, который выполняется на промисе в случае положительного исхода. По факту, мы просто передаем эту функцию как аргумент в параметр resolve.
    console.log(data);
}).catch(() => {
    // catch выполнится при какой-то ошибке. Он нужен для того, чтобы обработать reject. catch всегда ставится в конце. Блоки catch нужны для того, что если произошла какая-то ошибка на каком-то этапе, у нас сработает reject и мы сразу перескочим then и перейдём на catch.
    console.error("Произошла ошибка");
}).finally(() => {
    console.log("Finally");
});

// Мы делаем определенную цепочку из промисов. Причём then может принимать не только промисы, но и обычные данные.
// finally используется всегда после обработки всех взаимодействий и обработок ошибок. Он позволяет выполнить нам действия в абсолютно любом исходе промиса, то есть это действия которые должны быть произведены абсолютно всегда. Он ставится всегда в самом конце. Пример его использования: Нам отправляется обещание, что сервер примет успешно данные, либо не примет. Мы можем обработать его с помощью resolve. Если пошло все хорошо по положительному сценарию, то мы какие-то действия выполняем. Если пошло что-то не так, то срабатывает блок кода catch. И в finally мы можем поместить блок кода, где мы очищаем форму. Тут самое главное, что нам не важно, что если форма успешно обработалась или нет. Мы все равно выполняем finally, где форма очищается.

const test = time => {
    return new Promise(resolve => { // Можем передавать только resolve, но это редкость.
        setTimeout(() => resolve(), time);
    });
};

// test(1000).then(() => console.log("1000 ms"));
// test(2000).then(() => console.log("2000 ms"));

Promise.all([test(1000), test(2000)]).then(() => {
    console.log("All");
}); // Принимаем в себя массив из промисов. Она нужна для того, чтобы удостовериться в том, что все наши промисы уже выполнились. Он ждёт окончание всех промисов которые были переданы сюда в массив и только потом, он будет что-то выполнять.

Promise.race([test(1000), test(2000)]).then(() => { // Выполняет свои действия только когда самый первый промис уже отработал.
    console.log("All");
});